# 트리
- 비선형 구조.
  + 선형은 앞 뒤 1:1관계를 가지는 구조.
- 원소들 간에 1:n 관계를 가지는 자료구조.
- 원소들 간에 계층관계를 가지는 계층형 자료구조.
- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리모양의 구조.

## Tree의 용어
- 트리의 원소는 Node라고 한다.
- 트리는 하나 이상의 노드로 이뤄져있다.
- 노드 중 최상위 노드를 루트라고 한다.
- Root만 갖고 있으면 트리를 모두 탐색할 수 있다.
- 형제 노드 : 같은 부모 노드의 자식 노드들
- 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브 트리 : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들
- 노드의 차수 : 노드에 연결된 자식 노드의 수.
- 트리의 차수 : 트리에 있는 노드 차수들 중에 가장 큰 값.
- 단말 노드 : 차수가 0인 노드 즉, 자식 노드가 없는 노드.
- 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 루트는 0.
- 트리의 높이 : 트리에 있는 노드의 높이 중 가장 큰 값.

## 이진 트리
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리.
    + 왼쪽 자식 노드
    + 오른쪽 자식 노드
- 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리.
- 높이가 i인 이진트리의 노드의 최소 개수는 i+1개
- 높이가 i인 인진트리의 노드의 최대 개수는 2^(i+1)-1개

```java
class Node {
    Node left;
    Node right;
}
```

### 포화 이진 트리
- 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
- 루트를 1번으로 하여 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가짐.

### 완전 이진 트리
- 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리

### 편향 이진 트리
- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가진 이진 트리.

### 배열을 이용한 이진 트리의 표현.
- 루트 번호를 1로 함.
- 레벨 N을 기준으로, 왼쪽부터 2^n 부터 2^(n+1) - 1까지 번호를 차례로 부여.
- 배열은 선형, 트리는 비 선형 자료구조지만 인덱스의 위치를 유추할 수 있으므로 표현이 가능하다.
    + 논리는 트리이지만, 실제로는 배열이다.
    + 노드 번호가 i인 노드의 부모 노드 번호는 i/2
    + 노드 번호가 i인 노드의 왼쪽 자식 노드 번호는 2*i
    + 노드 번호가 i인 노드의 오른쪽 자식 노드 번호는 2*i+1
    + 레벨 n의 시작 번호는 2*n
    
### BFS, 너비 우선 탐색
- 루트 노드의 자식 노드들을 먼저 모두 차례로 방문한 후에, 방문했던 자식 노드들을 기준으로 하여 다시 탐색.
- 인접한 노드들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용.
- 자식 노드들에 대한 작업을 바로 처리하는 것이 아닌, 대기열로 사용하여 큐의 순서대로 사용하도록 설정.
```
BFS()
        큐 생성
        루트 v를 큐에 삽입
        while (큐가 비어 있지 않은 경우) {
            t <- 큐의 첫 번째 원소 반환
            t 방문
            for(t와 연결된 모든 간선에 대해) {
                u <- t의 자식노드
                u를 큐에 삽입
            }
        }
```

```java
public class CompleteBinaryTree {
    
    private char[] nodes;
    private final int SIZE;
    private int lastIndex; // 마지막에 추가된 노드의 인덱스
    
    public CompleteBinaryTree() {
        this.SIZE = size;
        nodes = new char[size+1];
    }
    
    public void add(char c) {
        if(lastIndex==SIZE) return;
            
        nodes[++lastIndex] = c;
    }
    
    public void bfs() {
        // 탐색을 기다리는 노드들이 저장됨.
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);        
   
        int current = 0;
        while(!queue.isEmpty()) {
            current = queue.poll();
            System.out.println(nodes[current]);
            if(current*2<=lastIndex) {
                queue.offer(current*2);
            }
            
            if(current*2+1<=lastIndex) {
                queue.offer(current*2+1);
            }
        }
    }
}
```