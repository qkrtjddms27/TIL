## 애그리거트
> 복잡한 도메인을 이해ㅔ하고 관리하기 쉬운 단위로 만들려면 사우이 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트다.

- 애그리거트는 관련된 객체를 하나의 군으로 묶어 준다.
- 수많은 객체를 애그리거트로 묶어서 바라보면서 상위수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 일관성을 관리하는 기준도 된다.
- 복잡한 도메인을 단순한 구조로 만들어준다.
- 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 가진다.
- 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리그거트를 관리하지 않는다.
  + 주문 애그리거트는 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지는 않는다.

### 애그리거트 설계 주의사항
> 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽다.
  + 주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 이는 어느정도 타당해 보인다.
  + `A가 B를 갖는다`로 해석할 수 있는 요구사항이 있다고 하더라도 이것이 반드시 A와 B가 한 애그리거트에 속한다는 의미는 아니다.
  + 사품 상세 페이지에 들어가면 상품 상세 정보와 함꼐 리뷰 내용을 보여줘야 한다는 요구사항이 있을 때
    * Product와 Review는 함께 생성되지 않고, 함께 변경되지도 않는다.
    * Product를 변경하는 주체가 상품 담당자라면 Review를 생성하고 변경하는 주체는 고객이다.
    * Reveiw의 변경이 Prodeuce에 영향을 주지 않고 반대로 Product의 변경이 Review에 영향을 주지 안힉 때문에 이 둘은 한 애그리거트에 속하기 보다는 서로 다른 애그리거트에 속한다.

- 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물었다.

## 애그리거트 루트
> 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
> 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다.

- 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티이다.
- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

### 도메인 규칙과 일관성
> 애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다. 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.

- 애그리거트 외부에서 다른 애그리거트에 속한 객체를 직접 변경하면 안 된다.
  + 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 두 가지를 습관적으로 적용해야 한다.
  + 단순히 필드를 변경하는 set 메서드를 공개 범위(public)로 만들지 않는다.
  + 밸류 타입은 불변으로 구현한다.
    * 밸류 객체의 값을 변경할 수 없으면 애그리거트 루트에서 밸류 객체를 구해도 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없다.
    * 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것 뿐이다.
- 밸류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.
```java
public class Order {
    private ShippingInfo shippingInfo;
    
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetSipped();
        setShippingInfo(newShippingInfo);
    }
    
    private void setShippingInfo(ShippingInfo newShippingInfo) {
        this.shippingInfo = newShippingInfo;
    }
}
```

### 애그리거트 루트의 기능 구현
> 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다. 예를 들어 Order는 총 주문 금액을 구하기 위해 OrderLine 목록을 사용한다.

```java
public class Order {
    private Money totalAmounts;
    private List<OrderLine> orderLines;
    
    private void calculateTotalAmounts() {
        int sum = orderLines.steam()
                .mapToInt(ol -> ol.getPrice() * ol.getQuantity())
                .sum();
        
        this.totalAmounts = new Money(sum);
    }
}
```

### 트랜잭션 범위
> 트랜잭션 범위는 작을수록 좋다. 한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다.
> 한 개 테이블을 수정하면 트랜잭션 충돌을 막기 위해 잠그는 대상이 한 개 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다.

- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
- 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높아진다.
  + 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
- 애그리거트는 최대한 서로 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아진다.
- 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

### 리포지터리와 애그리거트
> 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 리포지터리가 완전한 애그리거트를 제공하지 않으면 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NullPointerException과 같은 문제가 발생할 수 있다.
  + 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.
  + RDBMS를 이용해서 리포지터리를 구현하면 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있다.
  + NoSql를 사용하면 한 개 애그리거트를 한 개 문서에 저장함으로써 한 애그리거트의 변경을 손실 없이 저장소에 반영할 수 있다.


### ORM 직접참조
- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.
- 애그리거트 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한는 것과 같다.
- 예를 들어 주문 애그리거트에 속해 있는 Orderer는 주문한 회원을 참조하기 위해 회원 애그리거트 루트인 member를 필드로 참조할 수 있다.
- 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.
```java
public class Order{
    private Orderer orderer;
    ...
}

public class  Orderer {
    private Member member;
    private String name;
    ...
}

public class Member {
    ...
}

```

```
order.getOrderer().getMember().getId()
```
- 애그리거트를 직접 참조할 때 생기는 문제점
  + 확장 어려움
  + 편한 탐색 오용
  + 성능에 대한 고민

- 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다는 것이다.
  + 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.
  + 트랜잭션 범위에서 언급한 것처럼 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.
  
- 애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다는 것이다.
  + JPA를 사용하면 참조한 객체를 지연 로딩과 즉시 로딩의 두 가지 방식으로 로딩할 수 있다.
  + 두 로딩 방식중 무엇을 사용할지는 애그리거트의 어떤 기능을 사용하느냐에 따라 달라진다.
    * 연관된 객체의 데이터를 함께 화면에 보여줘야 하면 즉시 로딩이 조회 성능에 유리
    * 애그리거트의 상태를 변경하는 기능을 실행하는 경우에는 불필요한 객체를 함께 로딩할 필요가 없다.

- 확장, 초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다. 문제는 사용자가 몰리기 시작하면 사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다.
  + 도메인별로 시스템을 분산하기 시작.
  + 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음.

- 이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.
- DB 테이블에서 외래키로 참조하는 것과 비슷하게 ID를 이용한 참조는 다른 애그리거트를 참조할 때 ID를 사용한다.

### 객체가 아닌 ID 참조
> ID참조를 사용하면 모든 객체가 참조 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
- 애그리거트의 경게를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춘다.
- 다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 된다.

### N+1 문제
> 지연로딩과 마찬가지로 ID 참조 방식도 N+1문제로 인한 성능상에 문제가 생긴다.
- 조회를 위한 부분만 쿼리를 직접 작성하는 마이바티스를 이용해서 구현할 수도 있다.

### 애그리거트 간 집합 연관
> 애그리거트 간 1-N과 N-M 연관 관계.

```java
@ElementCollection
@CollectionTable(name = "product_category",
    joinColumns = @JoinColumn(name = "product_id"))
private Set<CategoryId> categoryIds;
```

#### 예제
```java
@Repository
public class JpaProductRepository implements ProductRepository {
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public List<Prodcut> findByCategoryId(CategoryId catId, int page, int size) {
        TypedQuery<Product> query = entityManger.createQuery(
                "select p from Product p " +
                "where :catId member of p.categoryIds order by p.id.id desc",
                Product.class
        );
        query.setParameter("catId", catId);
        query.setFirstResult((page-1) * size);
        query.setMAxResults(size);
        return query.getResultList();
    }
} 
```