# 키-값 저장소 설계

> 키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스이다.

- '키-값' 쌍이라고 지칭한다.
  + 이 저장소에 저장되는 고유 식별자를 키로 가져야 한다.
  + 성능상의 이유로 키는 짧을수록 좋다.
  + 값으로는 무엇이 오든 상관이없다.
    * 리스트 or 객체


## 문제 이해 및 설계 범위 확정
> 완벽한 설계란 없다. 읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를
> 만들었다면, 쓸만한 답안일 것이다.

- 키-값 쌍의 크기는 10KB이하
- 큰 데이터를 저장할 수 있어야 한다.
- 높은 가용성을 제공해야 한다. 따라서 시스템은 설사 장애가 있더라도 빨리 응답해야 한다.
- 높은 규모 확장성을 제공해야 한다. 따라서 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.
- 데이터 일관성 수준은 조정이 가능해야 한다.
- 응답 지연시간은 짧아야 한다.

## 단일 서버 키-값 저장소
> 한 대 서버만 사용하는 키-값 저장소를 설계하는 것은 쉽다. 

- 가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.
- 메모리에 모두 저장하는 것은 빠른 속도를 보장하지만 모든 데이터를 저장하는 것이 불가능 할 것이다.
  + `임시 방편1`, 데이터 압축을 통해 해결해 볼 수 있다.
  + `임시 방편2`, 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장
- 한 대 서버로 부족한 때는 결국 찾아올 것이다.
  + 분산 키-값 저장소를 만들 필요가 있다.

## 분산 키-값 저장소
> 분산 키-값 저장소는 분산 해시 테이블이라고도 불린다. 키-값 쌍을 여러 서버에 분산시키는 탓이다.

### 분산 서비스를 설계할때는 CAP를 이해하고 있어야한다.

- 일관성 consistency, 가용성 availability, 파티션 감내 partition tolerance
  + 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
  + 가용성 : 분산 시스템에 접속하는 클라이언트는 이루 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
  + 파티션 감내 : 파티션은 두 노드 사이에 통신 장에가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다.\

- 어떤 두 가지를 충족하려면 나머지 하나는 만드시 희생되어야 한다.
  + CP : 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성을 희생
  + AP : 가용성과 파티션 감내를 지원하는 키-값 저장소. 테이터 일관성을 희생
  + CA : 일관성과 가용성을 지원하는 키-값 저장소. 파티션 감내는 지원하지 않는다.
    * 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다. CA는 실존하지 않음.
  
### 이상적 상태
> 이상적 환경이라면 네트워크가 파티션되는 상황은 절대로 일어나지 않을 것이다. n1에 기록된 데이터는 자동적으로 n2와 n3에 복제된다.
> 데이터 일관성과 가용성도 만족한다.


#### 실세계의 분산 시스템
> 분산 시스템은 파티션 문제를 피할 수 없다.

- 파티션 문제가 발생하면 우리는 일관성과 가용성 사이에서 하나를 선택해야 한다.
- n3가 n1및 n2와 n3에 기록되었으나 아직 n1 및 n2로 전달되지 않은 데이터가 있다면 n1과 n2는 오래된 사본을 갖고 있을 것이다.
  + 세 서버 사이에서 발생할 수 잇는 불일치 문제를 피하기 위해 n1과n2에 대해 쓰기 연산을 중단시키야 하는데, 그렇게 하면 가용성이 깨진다.
- 은행권 시스템은 보통 데이터 일관성을 양보하지 않는다.

### 시스템 컴포넌트
> 키-값 저장소 구현에 사용될 핵심 컴포넌트들 및 기술들
- 데이터 파티션
- 테이터 다중화
- 일관성
- 일관성 불일치 해소
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로
- 읽기 경로

#### 데이터 파티션
> 대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.

- 데이터를 파티션 단위로 나눌 때는 다음 두 가지 문제를 중요하게 따져봐야 한다.
  + 데이터를 여러 서버에 고르게 분산할 수 있는가
  + 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가

- 안정해시를 사용하여 위 문제들을 해결할 수 있다.
  + 시스템 주하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.
  + 각 서버의 용량에 맞게 가상 노드의 수를 조절할 수 있다. 
    * 고성능 서버일수록 더 많은 가상 노드를 갖도록 설정할 수 있다.

#### 데이터 다중화
> 높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다. N은 튜닝 간으한 값.

- 안정해시 방식으로 만나는 N개의 서버에 순서대로 데이터 사본을 보관하는 것이다.
  + 단, 가상노드를 사용했다면 물리 서버의 중복선택을 피해야한다.
  
- 안전성은 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.

#### 데이터 일관성
> 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.

- 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
  + N = 사본 개수
  + W = 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 쓰기 연산이 성공했다는 응답을 받아야 한다.
  + R = 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.
  
- 일관성 모델
> 키-값 저장소를 설계할 때 고려해야 할 또 하나의 중요한 요소.
  
- 강한 일관성 : 모든 일긱 연산은 가장 최근에 갱신된 결과를 반환한다.
- 약한 일관성 : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
- 최종 일관성 : 약한 일관성이 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델이다.
  
- 비 일관성 해소 기법 : 데이터 버저닝 
> 데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.

- 버저닝과 벡터 시계는 일관성 문제를 해결할 수 있다.
  + 벡터 시계는 이런 문제를 푸는데 보편적으로 사용되는 기술.
    * 벡터 시계 : [서버, 버전]의 순서쌍을 데이터로 가진다.

- 장애 처리
> 대다수 대규모 시스템에서 장애는 그저 불가피하기만 한 것이 아니라 아주 흔한게 벌어지는 사건이다.

- 장애 감지
> 분산 시스템에서는 그저 한 대 서버가 "지금 서버 A가 죽었습니다"라고 한다 해서 바로 서버 A를 장애처리 하지는 않는다.

  - 각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.
  - 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.
  - 박동 카운터 목록을 받은 노드는 멤버십 목록을 주기적으로 자기 박동 카운터 목록을 보낸다.
  - 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.

- 일시적 장애 처리
>