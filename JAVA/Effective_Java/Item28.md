# 배열보다는 리스트를 사용하라
- 배열과 제네릭 타입에는 중요한 차이가 두 가지 있다.

## 첫 번째, 공변
- 배열은 공변이다.
  + Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.
- 제네릭은 불공변이다.
  + 서로 다른 타입 Type1과 Type2가 있을떄 List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다.

### 런타임, 컴파일 에러
```
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없음";
```

```
List<Object> ol = new ArrayList<Long>();
ol.add("타입이 달라 넣을 수 없다.");
```

- 둘 다 실패하는 것이 당연하다. 
  + Long 타입에 String 타입의 값을 넣을 수 없다

## 두 번째, 실체화
- 배열은 실체화된다.
  + 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
- 제네릭은 실체화되지 않는다.
  + 제네릭은 타입 정보가 런타임에는 소거된다.
  + 컴파일타임에만 검사하며 런타임에는 알수조차 없다.
- 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
  + new List<E>[], 제네릭 타입으로 사용할 수 없다.
  + new List<String>[], 매개변수화 타입으로 사용할 수 없다.
  + new E[], 타입 매개변수로 사용할 수 없다.
- 제네릭 배열을 만들지 못하게 막은 이유는 타입 이 안전하지 않기 때문이다.
  + 이를 허용한다면 ClassCastException이 발생한다. 이것은 런타임에 해당 Exception을 막아주는 취지에 어긋난다.

## 정리
- 배열과 제네릭은 확인하는 단계가 다르다. 
  + 컴파일단계, 런타임단계
    
- 이유는 공변과 실체화에 있다.
  + 배열은 공변이고 실체화된다
  + 제네릭은 불공변이고 타입 정보가 소거된다.
    
- 배열은 런타임단계에서 타입에 대해 안전하고, 반면 제네릭은 컴파인단계에서 안전하다.
  + 그래서 배열과 제네릭은 동시에 사용될 수 없다.